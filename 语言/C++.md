# static 
## 用法
1. 在函数体内，一个被声明为静态的变量不会因为函数返回而失效，在下一次调用时还会保持上一次的值，并且只开辟一次空间，而不是每次调用产生一个副本。
2. 一个被声明为静态的全局变量只能被同一文件中的函数访问。
3. 一个被声明为静态的函数只能被同一文件中的其他函数调用。
4. 在类中，一个成员变量被声明为静态的会使得该类所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员变量。
5. 在类中，一个成员函数被声明为静态的会使得不需要生成对象就可以访问该函数，但是在该函数内不能包含 this 指针，且只能调用静态成员(静态成员变量和静态成员函数)。
## 特点
- 防止在其他文件单元内被引用，static 全局变量只初始化一次。
- static 局部变量只被初始化一次，下一次调用依据上一次的结果值。
- static 函数在内存中只有一份，普通函数每次调用维持一份拷贝。
# 函数指针
# 引用与指针
## 引用
1. 本质：引用并非对象，而是为对象起了另外一个名字，是不分配空间的。
2. 非常量引用不能绑定到字面值或表达式的计算结果。
3. 一般来说，引用类型和绑定的对象类型需严格匹配。
4. 引用必须初始化，程序把引用和它的初始值绑定到一起，因此一旦初始化完成，无法令引用重新绑定到另外一个对象。
5. 引用本身并非对象，所以不能定义引用的引用。
## 指针
1. 指针不同于引用，指针本身就是一个对象，所以存在对指针的引用。
2. 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。
3. 一般来说，指针类型和指向的对象类型也需严格匹配。
4. 编译器并不负责检查试图拷贝或以其它方式访问无效指针的行为。
5. 和试图使用未经初始化的变量一样，使用无效指针的后果无法估计。
6. 把 int 型变量直接赋给指针是错误的，即使变量的值恰好等于 0。
7. 空指针不指向任何对象（不要混淆空指针和空类型(void)的指针）。
8. 空类型(void)指针用于存放任意对象的地址。
## 指针和引用的区别
- 引用不可以为空，但指针可以为空。
- 引用一旦初始化后不可以再改变其指向(但可以改变所指向对象的内容)，而指针可以改变其指向。
- 引用的大小是所指向的变量的大小，指针是指针（地址）本身的大小，在 32 位系统下一般为 4 个字节。
- 引用比指针更安全。由于不存在空引用，并且引用一旦被初始化指向一个对象，它就不能被改变成另一个对象的引用，因此引用很安全。对于指针而言，它可以随时指向别的对象，并且可以不被初始化或为 NULL，所以不安全。const 指针虽然不能改变其指向，但仍然存在空指针问题，并且有可能产生野指针（即多个指针指向一块内存，free 掉一个指针之后，别的指针就成了野指针）。
# malloc、free、new、delete
1. malloc 申请指定字节数的内存，申请到的内存中的初始值不确定。
2. free 只释放内存。
3. new 在申请内存时会自动计算所需字节数。
4. new / new[] 完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
5. delete / delete[] 也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
6. malloc 与 free 是 C++ / C 语言的标准库函数，new / delete 是 C++ 的运算符。
7. 对于非内部数据类型的对象而言，仅使用 malloc / free 是无法满足动态创建和消亡对象的要求的。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc / free 是库函数而不是运算符，是不在编译器控制权限之内的，不能够把执行构造函数和析构函数的任务强加于 malloc / free。因此 C++ 语言需要一个能完成动态内存分配和初始化工作的运算符——new，以及一个能完成清理与释放内存工作的运算符——delete。
# 多态
在 C++ 中，多态的实现是**在基类的函数前加上 virtual 关键字使其成为虚函数，并在派生类中重写该函数；该函数运行时会根据引用或指针绑定的对象的真实类型来决定要执行的版本。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。**
## 1. 多态性
多态性是面向对象程序设计（OOP）的核心思想，其字面意思是多种形态。

当我们使用基类的引用或者指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到**运行时**才会决定到底执行哪个版本，判断的依据是引用或指针绑定的对象的真实类型。

另一方面，对非虚函数的调用和通过对象进行的函数（虚函数或非虚函数）调用在**编译时**进行绑定。

## 2. 虚函数
对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。

基类通过在其成员函数的声明语句之前加上关键字 **virtual** 使得该函数执行动态绑定。**关键字 virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。**

**任何构造函数之外的非静态函数都可以是虚函数。**

如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。当然，我们可以再一次使用 virtual 关键字指出该函数的性质。

在 C++11 中我们可以使用 override 关键字来说明派生类中的虚函数。如果我们使用 override 标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。

通常情况下，如果我们不使用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。
## 3. 纯虚函数
我们通过在函数体的位置（即在声明语句的分号之前）书写 =0 就可以将一个虚函数说明为纯虚函数。其中，=0 只能出现在类内部的虚函数声明语句处。

和普通的虚函数不一样，一个纯虚函数无需定义。我们可以将纯虚函数的函数体定义在类的外部，但不能在类的内部为一个 =0 的函数提供函数体。

含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。**我们不能（直接）创建一个抽象基类的对象。**
## 4. 虚表
编译器会为每个包含虚函数的类创建一个虚函数表（或称虚表），该表是一个一维数组，在这个数组中存放每个虚函数的入口地址。编译器会在每个对象的前四个字节中保存一个虚表指针（即 vptr，一般作为类对象的第一个成员），指向对象所属类的虚表。

虚表和类是对应的，虚表指针和对象是对应的。**在构造函数中进行虚表的创建和虚表指针的初始化。**