# 移动零
> 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序

为了尽可能减少操作的次数，所以使用双指针，令其一个作为遍历的指针，另一个作为指向压缩后的数组的最后位置的指针。当遍历完成后，把剩余位置全部置零即可。
```cpp
    void moveZeroes(vector<int>& nums) {
        int size = nums.size();
        for (int i = 0, cur = 0; i < size; ++i) {
            if (nums[i] != 0) {
               swap(nums[cur++], nums[i]);
            }
        }
    }
```
* 时间复杂度：O(n)。但是，操作是最优的。代码执行的总操作（数组写入）是非 0 元素的数量。
* 空间复杂度：O(1)，只使用了常量空间。
# 找到所有数组中消失的数字
> 给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的整型数组，数组中的元素一些出现了两次，另一些只出现一次。找到所有在 [1, n] 范围之间没有出现在数组中的数字。要求不使用额外空间且时间复杂度为O(n)的情况下完成这个任务，可以假定返回的数组不算在额外空间内

首先进行一次遍历，将数组中每个元素的值的绝对值所对应的位置置为负数；再进行一次遍历，如果该位置的元素值为正，则将其下标加一的值压入结果数组。
```cpp
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int size = nums.size();
        vector<int> res;
        for (int i = 0; i < size; ++i) {
            int index = abs(nums[i]) - 1;
            if (nums[index] > 0) {
                nums[index] *= -1;
            }
        }
        for (int i = 0; i < size; ++i) {
            if (nums[i] > 0) {
                res.push_back(i + 1);
            }
        }
        return res;
    }
```
- 时间复杂度：O(N)。
- 空间复杂度：O(1)，因为我们在原地修改数组，没有使用额外的空间。
# 买卖股票的最佳时机
> 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润

计算每一天与当前已知价格最低的那一天的价格差，并保留最大的结果和价格最低的那一天的下标。
```cpp
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) {
            return 0;
        }
        int res = 0;
        int size = prices.size();
        for (int i = 1, min = 0; i < size; ++i) {
            int difference = prices[i] - prices[min];
            if (difference > res) {
                res = difference;
            } else if (difference < 0) {
                min = i;
            }
        }
        return res;
    }
``` 
- 时间复杂度：O(n)，只需要遍历一次。
- 空间复杂度：O(1)，只使用了常数个变量。
# 最大子序和
> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和

遍历数组寻找最大子段和，比较当前节点和加上下一个节点和单独下一个节点的值并保存大者且更新结果变量。换句话说就是，如果当前子段和是负数，则继续延长该字段是没有意义的，应重新开始计算子段和。
```cpp
    int maxSubArray(vector<int>& nums) {
        int res = nums[0], sum = 0;
        int size = nums.size();
        for (int num : nums) {
            sum = max(sum + num, num);
            res = max(res, sum);
        }
        return res;
    }
```
- 时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。
- 空间复杂度：O(1)。我们只需要常数空间存放若干变量。
# 两数之和
> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标
## 方法一：暴力法
```cpp
    vector<int> twoSum(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = i + 1; j < nums.size(); ++j) {
                if (nums[i] + nums[j] == target) {
                    vector<int> res;
                    res.push_back(i);
                    res.push_back(j);
                    return res;
                }
            }
        }
        return vector<int>();
    }
```
- 时间复杂度：O(n^2)。对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。
- 空间复杂度：O(1)。
## 方法二：一遍哈希表
遍历数组，将其元素与下标插入哈希表，寻找其**配对**元素是否已存在于哈希表中。
```cpp
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> map;
        for (int i = 0; i < nums.size(); ++i) {
            int difference = target - nums[i];
            if (map.count(difference) > 0) {
                vector<int> res;
                res.push_back(map[difference]);
                res.push_back(i);
                return res;
            }
            map[nums[i]] = i;
        }
        return vector<int>();
    }
```
- 时间复杂度：O(n)。我们只遍历了包含有 n 个元素的列表一次。在哈希表中进行的每次查找只花费 O(1) 的时间。
- 空间复杂度：O(n)。所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。
# 最短无序连续子数组
> 给定一个整数数组，寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序,输出找到的最短的子数组的长度

先从后往前找到降序排列的最后位置，再从前往后找到升序排列的最后位置，再找出这两个位置所夹区间中的最小值和最大值；从区间前端开始向前找到第一个小于最小值的位置，从区间后端开始向后找到第一个大于最大值的位置，这两个位置之差加一即为结果。
```cpp
    int findUnsortedSubarray(vector<int>& nums) {
        int size = nums.size();
        int i = 0, j = size - 1;
        while (j > 0 && nums[j] >= nums[j - 1]) {
            --j;
        }
        if (j == 0) {
            return 0;
        }
        while (i < j && nums[i] <= nums[i + 1]) {
            ++i;
        }
        int max_value = nums[i], min_value = nums[i];
        for (int k = i + 1; k <= j; ++k) {
            max_value = max(max_value, nums[k]);
            min_value = min(min_value, nums[k]);
        }
        while (i >= 0 && nums[i] > min_value) {
            --i;
        }
        while (j < size && nums[j] < max_value) {
            ++j;
        }
        return j - i - 1;
    }
```
- 时间复杂度：O(n)。使用了 4 个 O(n) 的循环。
- 空间复杂度：O(1)。使用了常数空间。
# 组合总和
> 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合

普通回溯题，有类似题目，此为加强版。
```cpp
    vector<vector<int>> res;
    vector<int> tmp;
    void combinationSum(vector<int>& candidates, int target, int i) {
        if (target <= 0) {
            if (target == 0) {
                res.push_back(tmp);
            }
            return;
        }
        int size = candidates.size();
        for (; i < size; ++i) {
            int candidate = candidates[i];
            tmp.push_back(candidate);
            combinationSum(candidates, target - candidate, i);
            tmp.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        combinationSum(candidates, target, 0);
        return res;
    }
```
- 时间复杂度：O(S)，其中 S 为所有可行解的长度之和。
- 空间复杂度：O(target)。
# 除自身以外数组的乘积
> 给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积

分别从左和从右遍历一遍数组，在遍历过程中使用一个变量保存其遍历过的元素的乘积和，并将其实时与结果数组中的元素相乘。
```cpp
    vector<int> productExceptSelf(vector<int>& nums) {
        int size = nums.size();
        vector<int> res;
        for(int i = 0, mul = 1; i < size; ++i) {
            res.push_back(mul);
            mul *= nums[i];
        }
        for(int i = size - 1, mul = 1; i >= 0; --i) {
            res[i] *= mul;
            mul *= nums[i];
        }
        return res;
    }
```
- 时间复杂度：O(N)，其中 N 指的是数组 nums 的大小。
- 空间复杂度：O(1)，输出数组不算进空间复杂度中，因此我们只需要常数的空间存放变量。
# 旋转图像
> 给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度

在单次循环中一次性旋转 4 个位置。
```cpp
    void rotate(vector<vector<int>>& matrix) {
        int size = matrix.size();
        for(int i = 0; i < size >> 1; ++i) {
            for (int j = i; j < size - 1 - i; ++j) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[size - 1 - j][i];
                matrix[size - 1 - j][i] = matrix[size - 1 - i][size - 1 - j];
                matrix[size - 1 - i][size - 1 - j] = matrix[j][size - 1 - i];
                matrix[j][size - 1 - i] = tmp;
            }
        }
    }
```
- 时间复杂度：O(N^2) 是两重循环的复杂度。
- 空间复杂度：O(1) 由于旋转操作是就地完成的。
# 最小路径和
> 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小

常规动态规划。
```cpp
    int minPathSum(vector<vector<int>>& grid) {
        int row = grid.size();
        int col = grid[0].size();
        if (row == 0 || col == 0) {
            return 0;
        }
        for (int i = 1; i < col; ++i) {
            grid[0][i] += grid[0][i - 1];
        }
        for (int i = 1; i < row; ++i) {
            grid[i][0] += grid[i - 1][0];
        }
        for (int i = 1; i < row; ++i) {
            for (int j = 1; j < col; ++j) {
                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);
            }
        }
        return grid[row - 1][col - 1];
    }
```
- 时间复杂度：O(mn)，其中 m 和 n 分别是网格的行数和列数。
- 空间复杂度：O(1)。