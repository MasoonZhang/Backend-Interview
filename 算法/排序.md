# 排序链表
>链表的自底向上的迭代的归并排序
```cpp
    ListNode* mergeList(ListNode* h1, ListNode* h2) {
        ListNode dummyHead(0);
        ListNode* tail = &dummyHead;
        while (h1 != nullptr && h2 != nullptr) {
            if (h1->val < h2->val) {
                tail->next = h1;
                tail = tail->next;
                h1 = h1->next;
            } else {
                tail->next = h2;
                tail = tail->next;
                h2 = h2->next;
            }
        }
        tail->next = h1 == nullptr ? h2 : h1;
        return dummyHead.next;
    }
    ListNode* splitList(ListNode* head, int length) {
        if (head == nullptr) {
            return nullptr;
        }
        while (head->next && --length) {
            head = head->next;
        }
        ListNode* next = head->next;
        head->next = nullptr;
        return next;
    }
    ListNode* sortList(ListNode* head) {
        ListNode dummyHead(0);
        dummyHead.next = head;
        ListNode* node = head;
        int length = 0;
        while (node) {
            node = node->next;
            ++length;
        }
        ListNode *tail, *cur, *left, *right;
        for (int i = 1; i < length; i <<= 1) {
            tail = &dummyHead;
            cur = dummyHead.next;
            while (cur) {
                left = cur;
                right = splitList(cur, i);
                cur = splitList(right, i);
                tail->next = mergeList(left, right);
                while (tail->next) {
                    tail = tail->next;
                }
            }
        }
        return dummyHead.next;
    }
```
* 时间复杂度：O(nlogn)
* 空间复杂度：O(1)
# 颜色分类
>经典三色问题

用双指针分别指向数组两端，一个扫描指针，碰见0和前面换，碰见2和后面换。
```cpp
    void sortColors(vector<int>& nums) {
        vector<int>::iterator left = nums.begin(), cur = nums.begin(), right = nums.end() - 1;
        while (cur <= right) {
            if (*cur == 0) {
                swap(*left++, *cur++);
            } else if (*cur == 2){
                swap(*right--, *cur);
            } else {
                ++cur;
            }
        }
    }
```
* 时间复杂度：由于对长度 N 的数组进行了一次遍历，时间复杂度为 O(N)。
* 空间复杂度：由于只使用了常数空间，空间复杂度为 O(1)。
# 合并区间
>给出一个区间的集合，请合并所有重叠的区间

先将所有区间排序，当当前区间的右端点大于下一个区间的左端点时，更新右端点；小于则直接加入结果数组。
```cpp
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> res;
        vector<vector<int>>::iterator it = intervals.begin();
        while (it != intervals.end()) {
            if (res.empty() || res.back()[1] < (*it)[0]) {
                res.push_back(*it);
            } else {
                res.back()[1] = max(res.back()[1], (*it)[1]);
            }
            ++it;
        }
        return res;
    }
```
* 时间复杂度：O(nlogn)，其中 n 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(nlogn)。
* 空间复杂度：O(logn)，其中 n 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(logn) 即为排序所需要的空间复杂度。