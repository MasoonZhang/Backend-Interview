# 最小栈
> 可快速取出栈中最小值的栈
## 方法一
可使用辅助栈保存最小值，换句话说就是主栈正常压入、弹出元素，辅助栈只压入不大于当前栈顶值的元素，弹出与当前栈顶相等的元素。辅助栈的栈顶元素的值表示此时主栈元素中的最小值。
```
    void push(int x) {
        _main_stack.push(x);
        if (_aux_stack.empty() || _aux_stack.top() >= x) {
            _aux_stack.push(x);
        }
    }
    
    void pop() {
        if (_main_stack.top() == _aux_stack.top()) {
            _aux_stack.pop();
        }
        _main_stack.pop();
    }
    
    int top() {
        return _main_stack.top();
    }
    
    int getMin() {
        return _aux_stack.top();
    }
```
* 时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。
* 空间复杂度：O(n)，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。
## 方法二
可使用辅助结构保存最小值，定义一个结构体，成员包括压入的元素和压入后的栈中的最小值
## 方法三
可自定义一个链表栈，附加一个最小值成员
# 有效的括号
>左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。

遍历到左括号时直接将其压入栈中，当遇到右括号时，若栈为空，则说明括号顺序错误，直接返回false；若栈不为空，则判断栈顶元素与当前字符是否配对，若不配对，可直接返回false；若配对，可弹出栈顶元素。
```
    bool isValid(string s) {
        stack<char> _stk;
        for (char c : s) {
            if (c == '(' || c == '{' || c == '[') {
                _stk.push(c);
            } else if (!_stk.empty() && ((c == ')' && _stk.top() == '(') || (c == '}' && _stk.top() == '{') || (c == ']' && _stk.top() == '['))) {
                _stk.pop();
            } else {
                return false;
            }
        }
        return _stk.empty();
    }
```
* 时间复杂度：O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。
* 空间复杂度：O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((。
```
    bool isValid(string s) {
        unordered_map<char, int> m{{'(', 1}, {'[', 2}, {'{', 3}, {')', -1}, {']', -2}, {'}', -3}};
        stack<int> _stk;
        char tmp;
        for (char c : s) {
            tmp = m[c];
            if (tmp > 0) {
                _stk.push(tmp);
            } else if (!_stk.empty() && !(_stk.top() + tmp)) {
                _stk.pop();
            } else {
                return false;
            }
        }
        return _stk.empty();
    }
```
# 二叉树的中序遍历
> 经典算法
## 方法一：递归
```
    vector<int> result_;
    vector<int> inorderTraversal(TreeNode* root) {
        if (root == nullptr) {
            return result_;
        }
        inorderTraversal(root->left);
        result_.push_back(root->val);
        inorderTraversal(root->right);
        return result_;
    }
```
* 时间复杂度：O(n)。递归函数 T(n) = 2 * T(n / 2) + 1。
* 空间复杂度：最坏情况下需要空间O(n)，平均情况为O(logn)。
## 方法二：迭代
```
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> stk;
        TreeNode* node = root;
        while (node != nullptr || !stk.empty()) {
            while (node != nullptr) {
                stk.push(node);
                node = node->left;
            }
            node = stk.top();
            stk.pop();
            result.push_back(node->val);
            node = node->right;
        }
        return result;
    }
```
* 时间复杂度：O(n)。
* 空间复杂度：O(n)。
# 每日温度
> 单调栈的使用

压入栈中的元素为下标值，遍历的索引值与栈中元素的差即为天数差。

当栈顶元素对应的温度小于当前日期的温度时，即满足题意，求出天数。当将栈中所有小于当前温度的日期全部弹出时，再将当前日期压入栈中，遍历完所有日期即可求得结果。因结果数组中元素初始化为0，则不用担心遍历完成时栈未清空的情况。
```
    vector<int> dailyTemperatures(vector<int>& T) {
        vector<int> result(T.size(), 0);
        stack<int> stk;
        for (int i = 0; i < T.size(); ++i) {
            while (!stk.empty() && T[i] > T[stk.top()]) {
                result[stk.top()] = i - stk.top();
                stk.pop(); 
            }
            stk.push(i);
        }
        return result;
    }
```
* 时间复杂度：O(n)，其中 n 是温度列表的长度。正向遍历温度列表一遍，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。
* 空间复杂度：O(n)，其中 n 是温度列表的长度。需要维护一个单调栈存储温度列表中的下标。