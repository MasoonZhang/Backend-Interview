# 最小栈
>可快速取出栈中最小值的栈
1. 可使用辅助栈保存最小值，换句话说就是主栈正常压入、弹出元素，辅助栈只压入不大于当前栈顶值的元素，弹出与当前栈顶相等的元素。辅助栈的栈顶元素的值表示此时主栈元素中的最小值。
```
    void push(int x) {
        _main_stack.push(x);
        if (_aux_stack.empty() || _aux_stack.top() >= x) {
            _aux_stack.push(x);
        }
    }
    
    void pop() {
        if (_main_stack.top() == _aux_stack.top()) {
            _aux_stack.pop();
        }
        _main_stack.pop();
    }
    
    int top() {
        return _main_stack.top();
    }
    
    int getMin() {
        return _aux_stack.top();
    }
```
2. 可使用辅助结构保存最小值，定义一个结构体，成员包括压入的元素和压入后的栈中的最小值
3. 可自定义一个链表栈，附加一个最小值成员
# 有效的括号
>左括号必须用相同类型的右括号闭合，左括号必须以正确的顺序闭合。

遍历到左括号时直接将其压入栈中，当遇到右括号时，若栈为空，则说明括号顺序错误，直接返回false；若栈不为空，则判断栈顶元素与当前字符是否配对，若不配对，可直接返回false；若配对，可弹出栈顶元素。
```
    bool isValid(string s) {
        stack<char> _stk;
        for (char c : s) {
            if (c == '(' || c == '{' || c == '[') {
                _stk.push(c);
            } else if (!_stk.empty() && ((c == ')' && _stk.top() == '(') || (c == '}' && _stk.top() == '{') || (c == ']' && _stk.top() == '['))) {
                _stk.pop();
            } else {
                return false;
            }
        }
        return _stk.empty();
    }
```
>判断是否配对可使用哈希表进行优化
```
    bool isValid(string s) {
        unordered_map<char, int> m{{'(', 1}, {'[', 2}, {'{', 3}, {')', -1}, {']', -2}, {'}', -3}};
        stack<int> _stk;
        char tmp;
        for (char c : s) {
            tmp = m[c];
            if (tmp > 0) {
                _stk.push(tmp);
            } else if (!_stk.empty() && !(_stk.top() + tmp)) {
                _stk.pop();
            } else {
                return false;
            }
        }
        return _stk.empty();
    }
``` 
