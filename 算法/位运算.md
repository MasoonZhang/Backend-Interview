# 汉明距离
>求出两个数字对应二进制位不同的位置的数目

两个数异或后二进制中1的个数即为答案。
```cpp
    int hammingDistance(int x, int y) {
        int xy = x ^ y;
        int res = 0;
        while (xy) {
            if (xy & 1) {
                ++res;
            }
            xy >>= 1;
        }
        return res;
    }
```
* 时间复杂度：O(1)，int 的大小是固定的，处理时间也是固定的。
* 空间复杂度：O(1)，使用恒定大小的空间。
在求1的个数时可进行优化。当一个数减一时，它会破坏掉其最右端的1，于是在与本身相与的过程中会得到一个只破坏掉最右端1的数。直至为零，循环次数即为所求。
```cpp
    int hammingDistance(int x, int y) {
        int xy = x ^ y;
        int res = 0;
        while (xy) {
            ++res;
            xy &= (xy - 1);
        }
        return res;
    }
```
* 时间复杂度：O(1)。与移位方法相似，由于整数的位数恒定，因此具有恒定的时间复杂度。但是该方法需要的迭代操作更少。
* 空间复杂度：O(1)，与输入无关，使用恒定大小的空间。
# 只出现一次的数字
>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素

将数组中所有整数相异或所得到的数即为所求。两个相等的数相异或为零。
```cpp
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for (int num : nums) {
            res ^= num;
        }
        return res;
    }
```
* 时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。
* 空间复杂度：O(1)。