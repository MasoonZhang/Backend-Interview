### 主机字节序与网络字节序

#### 主机字节序（CPU 字节序）

##### 概念

主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：

* 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址
* 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址

##### 存储方式

32 位整数 `0x12345678` 是从起始位置为 `0x00` 的地址开始存放，则：

内存地址 | 0x00 | 0x01 | 0x02 | 0x03
---|---|---|---|---
大端|12|34|56|78
小端|78|56|34|12

大端小端图片

![大端序](https://gitee.com/huihut/interview/raw/master/images/CPU-Big-Endian.svg.png)
![小端序](https://gitee.com/huihut/interview/raw/master/images/CPU-Little-Endian.svg.png)

##### 判断大端小端

判断大端小端

可以这样判断自己 CPU 字节序是大端还是小端：

```cpp
#include <iostream>
using namespace std;

int main()
{
	int i = 0x12345678;

	if (*((char*)&i) == 0x12)
		cout << "大端" << endl;
	else	
		cout << "小端" << endl;

	return 0;
}
```

## 7. 操作系统如何进行分页调度
1. **先进先出算法(FIFO)**:这种算法的实质是，总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。理由是：最早调入内存的页，其不再被使用的可能性比刚调入内存的可能性大。

2. **最优置换算法（OPT）**:当调入新的一页而必须预先置换某个老页时，所选择的老页应是**将来不再被使用**，或者是在最远的将来才被访问。采用这种页面置换算法，保证有最少的缺页率。
但是最优页面置换算法的实现是困难的，因为它需要人们预先就知道一个进程整个运行过程中页面走向的全部情况。

3. **LRU（最近最少使用）算法**
如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。LRU算法是经常采用的页面置换算法，并被认为是相当好的，但是存在如何实现它的问题。LRU算法需要实际硬件的支持。

4. **时钟算法()**:对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。 

### 4.1 分页存储管理
#### 4.1.1 基本思想
将程序的逻辑地址空间划分为固定大小的**页(page)**，而物理内存划分为同样大小的**页框(page frame)或物理块**，每个物理块的大小一般取2的整数幂。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）。

逻辑地址到物理地址变化原理：CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址(见图4-4)。
#### 4.1.2 页式管理方式的优点
- 没有外碎片，每个内碎片不超过页大小，提高内存的利用率。
- 一个程序不必连续存放。
- 便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。
#### 4.1.3 缺点
1. 无论数据有多少，都只能按照页面大小分配，容易产生**内部碎片**（一个页可能填充不满，造成浪费。
2. 不能体现程序逻辑
3. 分页方式的缺点是页长与程序的逻辑大小不相关
4. 不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。

### 4.2 分段存储
#### 4.2.1 思想
将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中（写c程序时会用到），并且每个程序可以有多个相同类型的段。段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。

段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。
在段式虚拟存储系统中，虚拟地址由段号和段内地址组成，虚拟地址到实存地址的变换通过段表来实现。

在为某个段分配物理内存时，可以采用**首先适配法、下次适配法、最佳适配法等**方法。在回收某个段所占用的空间时，要注意将收回的空间与其相邻的空间合并。

在段式虚拟存储系统中，虚拟地址由段号和段内地址组成，虚拟地址到实存地址的变换通过段表来实现。
#### 4.2.2 地址映射
在段式 管理系统中，整个进程的地址空间是**二维**的，即其逻辑地址由段号和段内地址两部分组成。为了完成进程逻辑地址到物理地址的映射，处理器会查找内存中的段表，由段号得到段的首地址，加上段内地址，得到实际的物理地址。这个过程也是由处理器的硬件直接完成的，操作系统只需在进程切换时，将进程段表的首地址装入处理器的特定寄存器当中。这个寄存器一般被称作段表地址寄存器。     

#### 4.2.3 分段存储方式的优缺点
分页对程序员而言是不可见的，而分段通常对程序员而言是可见的，因而分段为组织程序和数据提供了方便。与页式虚拟存储器相比，段式虚拟存储器有许多优点：

- 段的逻辑独立性使其易于**编译、管理、修改和保护**，也便于多道程序共享。
- 段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。
- 方便编程，分段共享，分段保护，动态链接，动态增长

因为段的长度不固定，段式虚拟存储器也有一些缺点：
 
- 主存空间分配比较麻烦。
- 容易在段间留下许多碎片（外部碎片），造成存储空间利用率降低。
- 由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚拟地址和实存地址的最低若干二进制位作为段内地址，并与段号进行直接拼接，必须用加法操作通过段起址与段内地址的求和运算得到物理地址。因此，**段式存储管理比页式存储管理方式需要更多的硬件支持**。

### 4.3 分页和分段的主要区别
- 页是信息的**物理单位**，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；段则是信息的**逻辑单位**，它含有一组其意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。

- 页的**大小固定且由系统决定**，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而**段的长度却不固定**，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。

- **分页的作业地址空间是一维的，即单一的线性地址空间**，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址是，即需给出段名，又需给出段内地址。

- 分页信息很难保护和共享、分段存储按逻辑存储所以容易实现对段的保存和共享。

### 4.4 段页存储
程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。

为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块

它首先将程序按其逻辑结构划分为若干个大小不等的逻辑段，然后再将每个逻辑段划分为若干个大小相等的逻辑页。主存空间也划分为若干个同样大小的物理页。辅存和主存之间的信息调度以页为基本传送单位，每个程序段对应一个段表，每页对应一个页表。

段页式系统中，作业的**地址结构包含三部分的内容：段号，页号，页内位移量**

CPU访问时，段表指示每段对应的页表地址，每一段的页表确定页所在的主存空间的位置，最后与页表内地址拼接，确定CPU要访问单元的物理地址。

**段页存储管理方式综合了段式管理和页式管理的优点，但需要经过两级查表才能完成地址转换，消耗时间多**。

#### 4.1.1 地址变换的过程：
- 进行地址变换时，首先利用段号S，将它与段表长TL进行比较。若S<TL，表示未越界。
- 于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址
- 利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b
- 利用块号和页内地址来构成物理地址。

#### 4.1.2 段页式存储管理的优缺点
优点:

 - (1) 它提供了大量的虚拟存储空间。
 - (2) 能有效地利用主存，为组织多道程序运行提供了方便。
 
缺点：

- (1) 增加了硬件成本、系统的复杂性和管理上的开消。
- (2) 存在着系统发生抖动的危险。
- (3) 存在着内碎片。
- (4) 还有各种表格要占用主存空间。

段页式存储管理技术对当前的大、中型计算机系统来说，算是最通用、最灵活的一种方案。